# Plan 03-01: Add Form Validation with Zod + React Hook Form

## Overview

Add client-side form validation to both contact forms (V1 and V2) using react-hook-form + Zod schema validation. This provides immediate feedback to users with bilingual error messages.

## Why This Matters

Contact forms currently accept any input with no validation. Users can submit invalid emails, empty fields, or incorrect data formats. Validation ensures quality quote requests and better user experience.

## Research Summary

**Libraries selected:**
- `react-hook-form` 7.55.0 (already installed) - Form state management
- `zod` - Schema validation with TypeScript type inference
- `@hookform/resolvers` - Bridge between react-hook-form and Zod

**Best practices from research:**
- Use `zodResolver` to connect Zod schemas with react-hook-form
- Validate `onBlur` mode for better UX (less intrusive than `onChange`)
- Infer TypeScript types from Zod schema using `z.infer<typeof schema>`
- Provide clear, bilingual error messages for all validation rules

## Tasks

- [ ] **Task 1**: Install validation dependencies
  - Install `zod` for schema validation
  - Install `@hookform/resolvers` for react-hook-form integration
  - Verify installation in package.json
  - Files: `package.json`, `pnpm-lock.yaml`

- [ ] **Task 2**: Create Zod validation schema
  - Define schema with validation rules:
    - Name: 2-50 characters required
    - Email: valid email format required
    - Project type: non-empty string required (V1 only)
    - Message: 10-1000 characters required
  - Add bilingual error messages (English + Korean)
  - Export TypeScript type using `z.infer`
  - Files: `src/lib/validations/contactSchema.ts` (new)

- [ ] **Task 3**: Update Contact.tsx with validation
  - Import `useForm` from react-hook-form
  - Import `zodResolver` from @hookform/resolvers
  - Connect Zod schema with `resolver: zodResolver(contactSchema)`
  - Register form fields with `register()`
  - Add error display below each input field
  - Set validation mode to `onBlur`
  - Files: `src/app/components/Contact.tsx`

- [ ] **Task 4**: Update ContactV2.tsx with validation
  - Apply same validation pattern as V1
  - Ensure consistent error display styling
  - Files: `src/app/components/v2/ContactV2.tsx`

- [ ] **Task 5**: Add error message translations
  - Add validation error keys to English translation
  - Add validation error keys to Korean translation
  - Ensure error messages use translation keys
  - Files: `src/locales/en/translation.json`, `src/locales/ko/translation.json`

- [ ] **Task 6**: Style validation error messages
  - Add error text styling (red color, small font)
  - Ensure error messages are accessible (aria-invalid, aria-describedby)
  - Test responsive layout with errors displayed
  - Files: `src/app/components/Contact.tsx`, `src/app/components/v2/ContactV2.tsx`

- [ ] **Task 7**: Test validation behavior
  - Test empty field submission
  - Test invalid email formats
  - Test message length validation
  - Test bilingual error messages (switch language)
  - Verify validation triggers onBlur
  - Run build to check for TypeScript errors
  - Files: None (manual testing)

## Acceptance Criteria

- [ ] Zod and @hookform/resolvers are installed
- [ ] Validation schema is defined with all rules
- [ ] Both Contact forms use react-hook-form with zodResolver
- [ ] Error messages display below fields when validation fails
- [ ] Error messages are bilingual (English + Korean)
- [ ] Validation triggers onBlur (not onChange)
- [ ] TypeScript types are inferred from Zod schema
- [ ] Forms prevent submission when validation fails
- [ ] Build passes with no TypeScript errors

## Dependencies

- Phase 2 complete (localization infrastructure)
- react-hook-form 7.55.0 (already installed)

## Technical Notes

**Validation Schema Example:**
```typescript
import { z } from 'zod';

export const contactSchema = z.object({
  name: z.string()
    .min(2, { message: 'validation.name.min' })
    .max(50, { message: 'validation.name.max' }),

  email: z.string()
    .email({ message: 'validation.email.invalid' }),

  projectType: z.string()
    .min(1, { message: 'validation.projectType.required' }),

  message: z.string()
    .min(10, { message: 'validation.message.min' })
    .max(1000, { message: 'validation.message.max' })
});

export type ContactFormData = z.infer<typeof contactSchema>;
```

**React Hook Form Integration:**
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { contactSchema, ContactFormData } from '@/lib/validations/contactSchema';

const { register, handleSubmit, formState: { errors } } = useForm<ContactFormData>({
  resolver: zodResolver(contactSchema),
  mode: 'onBlur'
});
```

**Error Display Pattern:**
```typescript
<Input {...register('email')} />
{errors.email && (
  <p className="text-sm text-red-600 mt-1">
    {t(errors.email.message)}
  </p>
)}
```

## Important Notes

**This plan does NOT include:**
- Form submission logic (handled in Plan 03-02)
- Email service integration (handled in Plan 03-02)
- Success/loading states (handled in Plan 03-02)

**This plan focuses solely on:**
- Client-side validation
- Error message display
- Type-safe form data

## Estimated Scope

Medium - Form validation setup requires careful integration with existing components and bilingual error messages.
